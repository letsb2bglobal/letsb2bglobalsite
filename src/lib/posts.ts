import { getToken } from './auth';

export interface Post {
  id: number;
  documentId: string;
  userId: number;
  description: string;
  destination: string;
  // category is now a plain JSON string or string[] — NOT a Strapi relation
  category?: string | string[];
  user_profile?: { id: number; company_name: string };
  status?: 'Open' | 'Closed';
  tags?: string[];
  createdAt: string;
  updatedAt: string;
  publishedAt: string;
  media?: any[];
  custom_attachments?: any[];
  _type?: 'post' | 'enquiry';
  _score?: number;
  // Legacy fields kept for backward-compat during transition
  title?: string;
  content?: any;
  roleType?: 'seller' | 'buyer';
  intentType?: 'demand' | 'offer';
  destinationCity?: string;
}

export interface PostResponse {
  data: Post[];
  meta?: {
    pagination?: {
      page: number;
      pageSize: number;
      pageCount: number;
      total: number;
    };
  };
}

export interface CreatePostData {
  userId: number;
  description: string;
  destination: string;
  // Plain string or array of strings — matches backend JSON field
  // Use display strings from TRADE_WALL_CATEGORIES (e.g. 'Hotel', 'Tour Operator')
  // NOT slugs like 'travel_agency' or Strapi connect objects
  category?: string | string[];
  status?: 'Open' | 'Closed';
  media?: number[]; // optional uploaded file IDs — do NOT send tags or content_hash
}

/**
 * Canonical category strings that match user-profile category_items[].category
 * and the TradeWall feed matching logic. Always use these exact strings.
 */
export const TRADE_WALL_CATEGORIES = [
  'Travel Agent',
  'Tour Operator',
  'Destination Management Company (DMC)',
  'Handling Partner',
  'Hotel',
  'Resort',
  'Homestay',
  'Service Villas',
  'Apartments',
  'Houseboats',
  'Cruise Liners',
  'Transport Provider',
  'Activity / Experience Provider',
  'Wellness Centres',
  'Ayurveda Centres',
  'Medical Tourism Facilitators',
  'Tourism Associations',
  'Hospitality Institutions',
  'Training Organisations',
] as const;

export type TradeWallCategory = typeof TRADE_WALL_CATEGORIES[number];

const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'https://api.letsb2b.com';

export const getAllPosts = async (): Promise<PostResponse> => {
  const token = getToken();
  
  if (!token) {
    throw new Error('No authentication token found');
  }

  try {
    const response = await fetch(`${apiUrl}/api/posts?sort=createdAt:desc`, {
      method: 'GET',
    });

    if (!response.ok) {
      throw new Error('Failed to fetch posts');
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
};

export const createPost = async (postData: CreatePostData): Promise<Post> => {
  const token = getToken();
  if (!token) throw new Error('No authentication token found');
  
  try {
    const response = await fetch(`${apiUrl}/api/posts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({
        data: {
          description: postData.description,
          destination: postData.destination,
          // Send category as plain string or array — never as a connect relation object
          ...(postData.category ? { category: postData.category } : {}),
          status: postData.status || 'Open',
          userId: postData.userId,
          // Do NOT send tags or content_hash — auto-generated by backend lifecycle
          ...(postData.media?.length ? { media: postData.media } : {}),
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      throw new Error(result?.error?.message || 'Failed to create post');
    }

    return result.data;
  } catch (error) {
    console.error('Error creating post:', error);
    throw error;
  }
};

/**
 * Update a post — only the owner can call this (backend enforces userId check)
 */
export const updatePost = async (
  documentId: string,
  updates: Partial<Omit<CreatePostData, 'userId'>>
): Promise<Post> => {
  const token = getToken();
  if (!token) throw new Error('No authentication token found');

  const response = await fetch(`${apiUrl}/api/posts/${documentId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ data: updates }),
  });

  const result = await response.json();
  if (!response.ok) throw new Error(result?.error?.message || 'Failed to update post');
  return result.data;
};

/**
 * Delete a post — only the owner can call this (backend enforces userId check)
 */
export const deletePost = async (documentId: string): Promise<void> => {
  const token = getToken();
  if (!token) throw new Error('No authentication token found');

  const response = await fetch(`${apiUrl}/api/posts/${documentId}`, {
    method: 'DELETE',
    headers: { Authorization: `Bearer ${token}` },
  });

  if (!response.ok) {
    const result = await response.json().catch(() => ({}));
    throw new Error(result?.error?.message || 'Failed to delete post');
  }
};
/**
 * Get all posts by a specific user
 * Uses the dedicated /api/posts/user/:userId endpoint (no auth required)
 */
export const getUserPosts = async (
  userId: number,
  options: { limit?: number; start?: number; sort?: string; status?: string } = {}
): Promise<Post[]> => {
  const params = new URLSearchParams();
  if (options.limit) params.set('limit', String(options.limit));
  if (options.start) params.set('start', String(options.start));
  if (options.sort) params.set('sort', options.sort);
  if (options.status) params.set('status', options.status);

  try {
    const response = await fetch(
      `${apiUrl}/api/posts/user/${userId}?${params.toString()}`,
      { method: 'GET' }
    );

    if (!response.ok) throw new Error('Failed to fetch user posts');
    const result = await response.json();
    // Endpoint returns raw array
    return Array.isArray(result) ? result : result.data ?? [];
  } catch (error) {
    console.error('Error fetching user posts:', error);
    throw error;
  }
};

/**
 * Get posts by user ID with full populate (media, attachments, user relation)
 * Uses /api/posts?filters[userId][$eq]=userId&populate=*&sort=createdAt:desc
 */
export const getPostsByUserId = async (userId: number): Promise<Post[]> => {
  const token = getToken();
  const params = new URLSearchParams();
  params.set('filters[userId][$eq]', String(userId));
  params.set('populate', '*');
  params.set('sort', 'createdAt:desc');

  try {
    const response = await fetch(`${apiUrl}/api/posts?${params.toString()}`, {
      method: 'GET',
      headers: {
        Authorization: token ? `Bearer ${token}` : '',
      },
    });

    if (!response.ok) throw new Error('Failed to fetch user posts');
    const result = await response.json();
    return Array.isArray(result) ? result : result.data ?? [];
  } catch (error) {
    console.error('Error fetching user posts:', error);
    throw error;
  }
};

/**
 * Search posts by text and location
 */
export const searchPosts = async (
  text: string,
  location: string
): Promise<PostResponse> => {
  const params = new URLSearchParams();
  if (text) params.append("text", text);
  if (location) params.append("location", location);

  try {
    const response = await fetch(`${apiUrl}/api/posts/search?${params.toString()}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      throw new Error("Failed to search posts");
    }

    const result = await response.json();
    
    // Handle both raw array and Strapi-style response { data: [] }
    if (Array.isArray(result)) {
      return { data: result };
    }
    
    return result;
  } catch (error) {
    console.error("Error searching posts:", error);
    throw error;
  }
};

/**
 * Log user engagement activity to improve feed ranking
 */
export const logActivity = async (data: {
  user: number;
  action_type: 'view' | 'click' | 'save' | 'reply';
  item_id: string; // documentId
  item_type: 'post' | 'enquiry';
}): Promise<void> => {
  const token = getToken();
  try {
    await fetch(`${apiUrl}/api/activity-logs`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: token ? `Bearer ${token}` : "",
      },
      body: JSON.stringify({ data }),
    });
  } catch (error) {
    console.error("Activity logging failed:", error);
  }
};

/**
 * Get the unified TradeWall feed (Posts + Enquiries)
 */
export const getTradeWallFeed = async (page: number = 1, pageSize: number = 10): Promise<PostResponse> => {
  const token = getToken();
  try {
    const response = await fetch(`${apiUrl}/api/trade-wall?page=${page}&pageSize=${pageSize}`, {
      method: "GET",
      headers: {
        Authorization: token ? `Bearer ${token}` : "",
      },
    });

    if (!response.ok) throw new Error("Failed to fetch TradeWall feed");
    return await response.json();
  } catch (error) {
    console.error("TradeWall error:", error);
    throw error;
  }
};

/**
 * Search the TradeWall with intelligent ranking
 */
export const searchTradeWall = async (params: {
  q?: string;
  category?: string; // documentId
  city?: string;
}): Promise<PostResponse> => {
  const token = getToken();
  const searchParams = new URLSearchParams();
  if (params.q) searchParams.append("q", params.q);
  if (params.category) searchParams.append("category", params.category);
  if (params.city) searchParams.append("city", params.city);

  try {
    const response = await fetch(`${apiUrl}/api/trade-wall/search?${searchParams.toString()}`, {
      method: "GET",
      headers: {
        Authorization: token ? `Bearer ${token}` : "",
      },
    });

    if (!response.ok) throw new Error("Search failed");
    return await response.json();
  } catch (error) {
    console.error("TradeWall search error:", error);
    throw error;
  }
};

/**
 * Upload Post Media
 */
export const uploadPostMedia = async (files: File[], data?: any): Promise<any> => {
  const token = getToken();
  if (!token) throw new Error("No authentication token found");

  const formData = new FormData();
  if (data) {
    formData.append("data", JSON.stringify(data));
  }
  files.forEach((file) => {
    formData.append("files", file);
  });

  const response = await fetch(`${apiUrl}/api/posts/upload`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
    },
    body: formData,
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData?.error?.message || "Failed to upload post media");
  }

  return await response.json();
};
